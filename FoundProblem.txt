# 25/08/28
- 在使用爬蟲找尋網頁的過程中，點擊按鈕後會記錄下這次發送的 request body。但是如果 API 包含 Token，同時這次自動化取得了 200 response，或許會讓這個 Token 失效，
進而導致後面重複使用 Token 的請求失敗。

    - 可能的解法

        - 使用 mitmproxy 看到 POST 請求後不送出，直接攔截下來。mitmproxy 可以自主回應 200 ok，這樣他就是還沒被用過的 Token。
            - (問)如果每個 API 能獨立做測試，這表示不需要前面瀏覽的狀態也能成功送出 API，那還大費周章建一棵樹的理由是甚麼?只要有API編號或可辨識字串就可以了吧?應該只需要API清單?
                - 這樣第二次做回測也就是察看 Response 時就有可以查閱的路徑，而且透過一條穩定的路由能夠快速產出完整的攻擊向量和報告

        - 在每次要送出請求時，都依照路由圖 run 一遍，產生全新的 Token 後在送出請求
            - (缺)實作上可能要依靠 Selenium 和 Requests 混用，感覺非常麻煩且很慢。
            - (優)這個能契合我所想要傳達的 Stateful 的概念，也才能凸顯 Api Tree 的功用所在。

    - 目前

        - 理論上 Token 沒被用過應該是能用的，而且網頁表單的輸入應該不會有太多是直接點擊可以 200 ok 的行為，我覺得先按照現有的演算法實作看看結果在下決定。
        如果能夠順利觸發的 API 很少，就要考慮改成用上面的解法實作。

# 25/09/04
- 我發現測到後面 Session 會過期，可能需要定期更換 Session
- 看能不能修改成 Ctrl + C 後一定會寫入 JSON

# 25/09/09
- 看能不能修改成 Ctrl + C 後一定會寫入 JSON [V]
- 我發現測到後面 Session 會過期，可能需要定期更換 Session (定期刷新的邏輯反而不好處理，在 Joomla admin pannel 可以設定 Session lifetime.) [?]
- admin pannel 的 installer 頁面不要動，這邊有太多插件是無關的  (多一個 function 設定是某個網頁不要動)
- 多一個功能是設定某些 API 不要動，例如 logout 的 api 不要動 [V]
- 在 Processing 處加上進度條 (已完成/未完成) 方便我查看目前進度。 (Grok 版有)
    - 有沒有可能加上 thread 加快速度 ?
- 在測試階段時點擊按鈕少了 required 值會不會可能降低能探索到的深度 (這好像無所謂)
- string index out of range (QQ)

- 目前主要問題 -> 樹狀結構建立問題 (應該要選擇一個 stable 的 cursor 或 grok 的版本，先確定可以正常掃描網站，然後自己改樹狀結構的寫入邏輯)
    1. 建立樹狀結構根結點選擇問題 (Wire.py 版本)
    2. 樹狀結構無法呈現全部的 urls，例如 admin pannel 裡面有一堆 url，但即使檢測到也掃描過 url，但就是沒辦法被記載入樹狀結構 (Grok.py 版本)


# 25/09/10

建立四個物件
- [V] VisitedUrl (set), 用來儲存走訪過什麼 url，不要出現環(原本的就可以)
- [V] ParentMap (dict), {url:parent} 可以在當前 url 在找尋網頁中的 <a> tag 時匯入，例如 index.php 網頁中有 article 就會是當 driver 在 /index.php 時匯入資訊 {'/article':'/index.php'}
- UrlToApis (dict), {url:apis:{}} 因為每個 url 底下的 api 不會具有深度的特性，所以直接另外取出來儲存。
- [V] UrlToNode (dict), {url:children} 這個在最後建樹階段時建立，是在未來方便查詢這個樹所建立的 index 表
                    {str:list}
- 建樹: 走訪 ParentMap，因為在掃描過程使用的是 BFS，所以 ParentMap 匯入的 Key 值順序會契合匯入的節點 Lavel，不會有提前需要匯入較深節點的問題，所以 Tree 會製作成
{
    rooturl:
        children: {
            suburl1: {
                children :{
                    subsuburl1 : {

                    }
                }
            }, 
            suburl2: {
                children :{
                    subsuburl1 :{

                    }
                }
            }
            ...
        }
}

在建樹時因為 ParentMap 的插入順序，會讓 suburl 層先被匯入(再搭配指向的 parent 可以確定應該將節點放在樹的何處)，
這時候就能在 UrlToNode 裡面建立第一個值 {root:[suburl1, suburl2]}，當 suburl1 都走過一次後會開始走到 suburl1 會建立為 {root:[suburl1, suburl2], suburl1:[]}
如此往復就能把 node 資訊完好無缺的存入 UrlToNode 裡面。

這邊只存 url 即可，因為 api 儲存僅收錄當前頁面中的，api，不需要考慮深度問題，所以僅需要一個扁平的 {url:{apis} }(裡面儲存的資料必須要包含整個 request body, header 等)

未來要查詢時就能透過 O(1) 的時間查詢到任何 url 之下的 children，同時能夠透過 url 查詢 api，甚至也能透過 ParentMap 查詢 previous 的 node。

(以上全部 url 皆已絕對路徑儲存，修改 Grok 那份 code 比較快，因為裡面還有 exclude url 的功能在)

目前 Grok 版本已經能正確輸出 tree.json，但還沒讓 Api 也 sync 起來